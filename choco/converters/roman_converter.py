"""
Implementation of a converter that takes in input a chord annotated using
the Roman Numeral notation, and converts it into the Hart notation.
"""
import csv
import re


def decompose_roman(roman_chord: str):
    """
    Converts a Roman Numeral chord into Harte Notation, taking into consideration
    the key context in which the chord is played.
    Parameters
    ----------
    roman_chord : str
        The single chord to be converted given as a string.
        The string, according to the implementation of m21_parser and
        related code, is composed by two sections, colon separated:
        [key]:[roman_chord]
    Returns
    -------
    harte_chord : str
        Returns a string which is the roman chord converted taken as
        input converted into Harte notation.
    """
    print(roman_chord)
    # preprocess the input chord for removing dataset errors
    if bool(re.search(':$', roman_chord)):
        roman_chord = re.sub(':$', '', roman_chord)

    # decompose the chord into its parts
    key, chord = roman_chord.split(':')
    key, mode = key.split(' ')
    root = ''
    if '/' in roman_chord:
        chord, *root = chord.split('/')

    # extract from chord the grade
    roman_re = re.compile('^([+-b#]{0,3})(?i)(IX|IV|V?I{0,3})(Ã¸|o{0,1})[0-9]{0,5}')
    chord_filtered = roman_re.findall(chord).extend(root)
    return [key, mode, chord, chord_filtered]


def test_roman_conversion(stats_file):
    """
    Tests the chord converter using the statistics file generated by stats.py.
    TODO: move this function in a separated file
    """
    with open(stats_file) as csv_file:
        stats = csv.reader(csv_file, delimiter=',')

        for i, chord_data in enumerate(stats):
            if i != 0:
                processed_chord = decompose_roman(chord_data[0])
                print(processed_chord)


if '__main__' == __name__:
    test_roman_conversion('../../partitions/when-in-rome/choco/chord_stats.csv')
