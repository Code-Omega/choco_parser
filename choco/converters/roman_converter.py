"""
Implementation of a converter that takes in input a chord annotated using
the Roman Numeral notation, and converts it into the Hart notation.
"""
import csv
import re

from choco.utils import get_note_index
from typing import Tuple


def decompose_roman(roman_chord: str) -> Tuple:
    """
    Converts a Roman Numeral chord into Harte Notation, taking into consideration
    the key context in which the chord is played.
    Parameters
    ----------
    roman_chord : str
        The single chord to be converted given as a string.
        The string, according to the implementation of m21_parser and
        related code, is composed by two sections, colon separated:
        [key]:[roman_chord]
    Returns
    -------
    decomposed_chord : Tuple
        Returns a tuple containing the constituent elements of the Roman Chord,
        namely:
        - a list containing the key and the mode in which the chord is played
        - a tuple containing the chord decomposed, which contains elements in this order:
            * any alteration that can be found before the chord notation
            * the roman chord notation itself
            * any alteration to the chord (e.g. inversions: 46)
            * any added or removed note (between square brackets)
        - a list of root notes (originally indicated after the slash "/")
    """
    # preprocess the input chord for removing dataset errors
    if roman_chord == 'Bb major:V7IV':
        roman_chord = roman_chord.replace('V7IV', 'V7/IV')
    if bool(re.search(':$', roman_chord)):
        roman_chord = re.sub(':$', '', roman_chord)

    # decompose the chord into its parts
    key, chord = roman_chord.split(':')
    key, mode = key.split(' ')
    root = ''
    if '/' in roman_chord:
        chord, *root = chord.split('/')

    # extract from chord the grade
    roman_re = re.compile('^([#b+-]{0,3})(?i)(It|N|Cad|N6|Fr|Ger|IX|IV|V?I{0,3})?'
                          '(Ã¸|o|d|maj2|maj4|maj6|maj7|\+?)([b#M0-9+-]{0,9})(\[.*\]{0,2})?')
    chord_filtered = roman_re.findall(chord)
    final = [key, mode], chord_filtered[0], root
    return final


def convert_roman_numeral(roman_numeral: str, key: list) -> str:
    """
    Converts a roman numeral into a base chord. It does not consider any chord
    alteration or modifier to the chord.
    Parameters
    ----------
    roman_numeral : str
        A Roman numeral grade as returned by the decompose_roman function in
        position [1][1]. This function does not consider alterations.
    key : list
        The key in which the chord takes place. The key has to be provided
        as a list made of two elements, namely the key itself and the mode
        (only major and minor supported soi far).
    Returns
    -------
    base_note : str
        A string indicating the base chord (as described by the Harte notation),
        without any alteration or modifier.
    """
    key_index = get_note_index(key[0])
    return key_index


def test_roman_conversion(stats_file):
    """
    Tests the chord converter using the statistics file generated by stats.py.
    TODO: move this function in a separated file
    """
    with open(stats_file) as csv_file:
        stats = csv.reader(csv_file, delimiter=',')

        for i, chord_data in enumerate(stats):
            if i != 0:
                processed_chord = decompose_roman(chord_data[0])
                print(processed_chord)


if '__main__' == __name__:
    test_roman_conversion('../../partitions/when-in-rome/choco/chord_stats.csv')
    print(convert_roman_numeral('C', ['C', 'min']))
