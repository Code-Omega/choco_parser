"""
Converter for Roman Numeral chord annotations based on Music21.
"""
from music21 import roman, pitch, chord, interval, key, note

from choco.converters.utils import open_stats_file
from typing import Tuple, List


def decompose_roman(roman_chord: str) -> Tuple:
    key, roman = roman_chord.split(':')
    key_root, mode = key.split(' ')
    key = key_root.upper() if mode == 'major' else key_root.lower()
    return key, roman


def calculate_interval(note_1: note, note_2: note, simple: bool = False) -> str:
    # if bass and root do not correspond, calculate the bass degree
    mode = 'simpleName' if simple is True else 'semiSimpleName'
    bass_interval = getattr(interval.Interval(note_1, note_2), 'directedName')
    print('########', interval.Interval(note_2, note_1))
    return convert_intervals(bass_interval)


def convert_intervals(m21_interval: str) -> str:
    substitutions = {
        'M': '',
        'm': 'b',
        'P': '',
        'd': 'b',
        'A': '#',
    }
    return m21_interval.translate(m21_interval.maketrans(substitutions))


def convert_root(chord: chord) -> str:
    root_note = str(chord.root())
    root = ''.join(x for x in root_note if not x.isdigit())
    return root.replace('-', 'b')


def simplify_harte(harte_chord: str) -> str:
    pass


def convert_roman(roman_chord: str) -> str:
    # get the decomposed chord
    key, roman_notation = decompose_roman(roman_chord)

    try:
        chord = roman.RomanNumeral(roman_notation, key)
    except ValueError:
        raise ValueError('Impossible to convert the given Roman Numeral.')

    root, bass = chord.root(), chord.bass()
    bass_interval = calculate_interval(root, bass, simple=True)

    pitch_names = chord.pitchNames
    chord_intervals = [calculate_interval(note.Note(root), note.Note(x)) for x in pitch_names]
    root = convert_root(chord)
    chord.annotateIntervals(inPlace=True, stripSpecifiers=False, sortPitches=False)
    # print(chord.lyrics)
    print(roman_chord)
    print(chord.pitchNames)
    print(chord_intervals)
    print(chord.root(), chord.bass())
    # chord_interval = ','.join(convert_intervals(chord_interval[::-1]))

    # return f'{root}:({chord_interval}){bass_interval}'


def test_roman_conversion(stats_file: str) -> None:
    """
    Tests the chord converter using the statistics file generated by stats.py.
    TODO: move this function in a separated file
    """
    stats = open_stats_file(stats_file)

    for chord_data in stats:
        print(chord_data)
        try:
            print(convert_roman(chord_data[0]))
        except pitch.AccidentalException:
            print('ERROR')


if '__main__' == __name__:
    # test_roman_conversion('../../partitions/when-in-rome/choco/chord_stats.csv')
    # convert_roman('E major:V42')
    print(interval.Interval(note.Note('b'), note.Note('a#')))
